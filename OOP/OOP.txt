База данных работников предприятия для бухгалтерии.

ВНИМАНИЕ: реализация на Java, в которой множественное наследование запрещено, и в качестве его аналога применяются объекты, называющиеся Интерфейсы.

1. На первом этапе мы создаем абстрактный класс работника Employee. Класс содержит поля (переменные), содержащие определенные сведения об объекте. Сведения не любые, а исключительно те, которые нужны нам для выполнения цели программы - ФИО, должность, ставка заработной платы за 1 час, и прочее. Также класс содержит в себе некоторые абстрактные методы (функции), например, вызов метода вычисления размера заработной платы из интерфейса (см. далее). Поля и методы приватим, ставим геттеры/сеттеры - их неправильное использование будет уже не на нашей совести. 
У нас на предприятии существует несколько форм оплаты труда. Кто-то получает почасовую оплату, кто-то - сдельную, у кого-то бонусы за руководство. Под каждую форму оплаты мы создаем отдельный интерфейс. 
Тут мы применяем принцип абстракции и инкапсуляции.
2. Пришло время создавать конкретные классы должностей сотрудников! Например, должность программиста. Класс Programmer. Он будет наследовать от класса Employee, с имплементацией интерфейса, соответствующего форме оплаты этой должности. В случае необходимости - возможно переопределение методов родительского класса, введение дополнительных полей. 
Реализация в коде конкретного способа оплаты не должна волновать бухгалтера - поэтому смело приватим методы расчета зарплаты, давая возможность бухгалтеру только ввести входные параметры (оплата за час, размер бонуса), и получить готовый результат - размер з/п. "Черный ящик" своеобразный.
Это пример наследования и инкапсуляции.
3. Итак, у нас на предприятии работает 6 программистов, 4 тестировщика, и 1 тим-лидер. Создаем соответствующие экземпляры классов Programmer, Tester и TeamLeader. Было бы удобно хранить все данные в одном месте. Соответственно, создаем коллекцию Bookkeeping, способную хранить объекты класса Employee и всех его дочерних классов, и в нее включаем всех наших сотрудников. При вызове метода, начисляющего заработную плату, сработает тот метод, который переопределен в конкретном дочернем классе, с учетом имплементированного интерфейса.
Это пример полиморфизма.

По сути, основные достоинства ООП - возможность разбить большую задачу на небольшие подзадачи, а также легко вносить изменения в работу программы без изменения кода в целом. Вышеописанная схема этим требованиям отвечает. Мы легко можем добавить новые должности (например, водителя), легко можем изменить порядок начисления заработной платы для конкретных должностей (например, увеличить ставку отчислений НДФЛ, просто поменяв одну static final переменную в интерфейсе), и так далее.